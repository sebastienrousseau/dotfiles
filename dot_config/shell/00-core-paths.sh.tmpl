#!/usr/bin/env bash

# Universal Paths (Generated by Chezmoi)
# Note: XDG variables are set in ~/.zshenv (Bootloader)

# 1. System Paths (Prepend, but will be pushed down by later prepends)
export PATH="/usr/bin:/bin:/usr/sbin:/sbin:${PATH}"

# 2. Homebrew Paths (Prepend -> Higher Priority)
if [[ -d "/opt/homebrew/bin" ]]; then
    export PATH="/opt/homebrew/bin:/opt/homebrew/sbin:${PATH}"
fi

# 3. Language Runtimes
# Ruby (Homebrew)
if [[ -d "/opt/homebrew/opt/ruby/bin" ]]; then
    export PATH="/opt/homebrew/opt/ruby/bin:${PATH}"
fi
# Ruby (User Gems)
export PATH="${HOME}/.gem/ruby/bin:${PATH}"

# Python (Pipx)
export PIPX_HOME="${XDG_DATA_HOME:-$HOME/.local/share}/pipx"
export PIPX_BIN_DIR="${XDG_BIN_HOME:-$HOME/.local/bin}"
export PATH="${PIPX_BIN_DIR}:${PATH}"

# Rust (Cargo)
export PATH="${HOME}/.cargo/bin:${PATH}"

# Go
export PATH="${HOME}/go/bin:${PATH}"

# Bun
export BUN_INSTALL="${HOME}/.bun"
export PATH="${BUN_INSTALL}/bin:${PATH}"

# Kubeconfig merge logic (merge all configs in ~/.kube/config.d/)
# Lazy-loaded via kubectl wrapper to avoid startup cost
_lazy_load_kubeconfig() {
    if [[ -d "${HOME}/.kube/config.d" ]]; then
        local kubeconfig_extra=""
        for conf in "${HOME}/.kube/config.d"/*; do
            [[ -f "$conf" ]] && kubeconfig_extra="${kubeconfig_extra}:${conf}"
        done
        [[ -n "$kubeconfig_extra" ]] && export KUBECONFIG="${HOME}/.kube/config${kubeconfig_extra}"
    fi
    unfunction kubectl _lazy_load_kubeconfig 2>/dev/null
    command kubectl "$@"
}
# Only wrap kubectl if config.d exists and kubectl is installed
if [[ -d "${HOME}/.kube/config.d" ]]; then
    kubectl() { _lazy_load_kubeconfig "$@"; }
fi
# Still honor explicit KUBECONFIG or in-cluster detection
if [[ -n "${KUBERNETES_SERVICE_HOST:-}" ]] || [[ -n "${KUBECONFIG:-}" ]]; then
    _lazy_load_kubeconfig --version >/dev/null 2>&1 || true
fi

# Node.js (Global)
export PATH="${HOME}/.node_modules/bin:${PATH}"

# Lua (Luarocks)
export PATH="${HOME}/.luarocks/bin:${PATH}"

# 4. Applications (macOS Specifics from 99-custom)
export PATH="/Library/Apple/usr/bin:/Library/TeX/texbin:${PATH}"
export PATH="/Applications/Topaz Photo AI.app/Contents/Resources/bin:/Applications/Little Snitch.app/Contents/Components:/Applications/iTerm.app/Contents/Resources/utilities:${PATH}"
export PATH="/Applications/Visual Studio Code.app/Contents/Resources/app/bin:${PATH}"

# 5. Local Bin (Highest Priority)
export PATH="${HOME}/.local/bin:${PATH}"
export PATH="${HOME}/bin:${PATH}"

# Deduplicate PATH (Keep first occurrence to maintain precedence)
# Standard Zsh handles this with 'typeset -U path', but for bash compatibility/subshells:
if [ -z "${ZSH_VERSION:-}" ]; then
    # Use native bash associative arrays for O(n) deduplication (bash 4+)
    if [[ ${BASH_VERSION%%.*} -ge 4 ]]; then
        declare -A _seen_paths
        IFS=':' read -ra _path_array <<< "$PATH"
        _new_path=""
        for _dir in "${_path_array[@]}"; do
            if [[ -n "$_dir" && -z "${_seen_paths[$_dir]:-}" ]]; then
                _seen_paths[$_dir]=1
                _new_path="${_new_path:+$_new_path:}$_dir"
            fi
        done
        PATH="$_new_path"
        unset _seen_paths _path_array _new_path _dir
    else
        # Fallback to awk for bash 3.x
        PATH=$(echo "$PATH" | awk -v RS=':' '!seen[$0]++ {ORS=(NR>1?":":"")} {print}')
    fi
    export PATH
fi
